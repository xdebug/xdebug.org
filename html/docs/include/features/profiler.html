<a name="introduction"></a>
<h2>Introduction</h2>

<p>Xdebug's Profiler is a powerful tool that gives you the ability to analyse
your PHP code and determine bottlenecks or generally see which parts of your
code are slow and could use a speed boost. Since Xdebug 2.6, the profiler also
collects information about how much memory is being used, and which functions
and methods increase memory usage.</p>

<p>The profiler in Xdebug outputs
profiling information in the form of a Cachegrind compatible file.  This allows
you to use the excellent <a href="https://kcachegrind.github.io">KCacheGrind</a>
tool (Linux, KDE) to analyse your profiling data. If you are on Linux
you can install KCacheGrind with your favourite package manager.</p>

<p>If you are on Windows, there are precompiled <a
href="http://sourceforge.net/projects/qcachegrindwin/">QCacheGrind</a>
binaries available. (QCacheGrind is KCacheGrind without KDE bindings).</p>

<p>If you are on Mac OSX, there are <a
href="http://www.tekkie.ro/computer-setup/how-to-install-kcachegrind-qcachegrind-on-mac-osx/">instructions</a>
on how to build QCacheGrind too.</p>

<p>Users of Windows can alternatively use
<a href="http://ceefour.github.io/wincachegrind/">WinCacheGrind</a>. The
functionality is different from KCacheGrind so the section that documents the
use of KCacheGrind on this page doesn't apply to this program. WinCacheGrind
currently does not support the file and function compression for cachegrind
files that Xdebug 2.3 introduces yet.</p>

<p>There is also
an alternative profile information presentation tool called
<a href="https://github.com/alexeykupershtokh/xdebugtoolkit">xdebugtoolkit</a>, a web
based front-end called <a
href="https://github.com/jokkedk/webgrind">Webgrind</a>, and a Java based tool
called <a
href="http://sourceforge.net/projects/xcallgraph/">XCallGraph</a>.</p>

<p>In case you can not use KDE (or do not want to use KDE) the kcachegrind
package also comes with a perl script "ct_annotate" which produces ASCII output
from the profiler trace files.</p>

<a name="starting"></a>
<h2>Starting The Profiler</h2>

<p>Profiling is enabled by setting the
[CFG:profiler_enable] setting
to 1 in php.ini. This instructs Xdebug to start writing profiling information
into the dump directory configured with the
[CFG:output_dir]
directive. The name of the generated file always starts with
"<span class="filename">cachegrind.out.</span>" and ends with either the PID
(process ID) of the PHP (or Apache) process or the crc32 hash of the
directory containing the initially debugged script. Make sure you have enough
space in your [CFG:output_dir] as the amount of information generated by the profiler can be
enormous for complex scripts, for example up to 500MB for a complex application
like <a href="http://ez.no">eZ Publish</a>.</p>

<p>You can also selectively enable the profiler with the
[CFG:profiler_enable_trigger] setting set to 1. If it is set to 1, then you can
enable the profiler by using a GET/POST or COOKIE variable of the name
XDEBUG_PROFILE. The FireFox 2 extension that can be used to enable the debugger
(see <a href="/docs/remote#firefox-ext">HTTP Debug Sessions</a>) can also be
used with this setting. In order for the trigger to work properly,
[CFG:profiler_enable] needs to be set to 0.</p>

<p>From Xdebug 2.6 onwards, Xdebug adds the HTTP header
<code>X-Xdebug-Profile-Filename</code> to a request that is being profiled.
This header contains the name of the file that holds the profiling information
for that request.</p>

<a name="misc"></a>
<h2>Analysing Profiles</h2>

<p>After a profile information file has been generated you can open it with
<a href="https://kcachegrind.github.io">KCacheGrind</a>:</p>

<p><img src="/images/docs/kc-open.png"/></p>

<p>Once the file is opened you have plenty of information available in the
different panes of <a href="https://kcachegrind.github.io">KCacheGrind</a>. On the left side you find the "Flat Profile"
pane showing all functions in your script sorted by time spent in this function,
and all its children.
<img class="l" src="/images/docs/kc-profile.png" align="left"/>
The second column "Self" shows the time spent in this function (without its
children), the third column "Called" shows how often a specific function was
called and the last column "Function" shows the name of the function. Xdebug
changes internal PHP function names by prefixing the function name with
"php::" and include files are handled in a special way too. Calls to include
(and include_once, require and require_once) are followed by "::" and the
filename of the included file. In the screenshot on the left you can see this
for "include::/home/httpd/ez_34/v..." and an example of an internal PHP
function is "php::mysql_query".
<img class="r" src="/images/docs/kc-percentage.png" align="right"/>
The numbers in the first two columns can be
either percentages of the full running time of the script (like in the
example) or absolute time (1 unit is 1/1.000.000th of a second). You can
switch between the two modes with the button you see on the right.</p>

<p>The pane on the right contains an upper and lower pane. The upper one
shows information about which functions called the current selected function
("eztemplatedesignresource-&gt;executecompiledtemplate in the screenshot).
<img class="r" src="/images/docs/kc-right-call.png" align="right"/>
The lower pane shows information about the functions that the current selected
function called.</p>

<p>The "Cost" column in the upper pane shows the time spent in the current
selected function while being called from the function in the list. The numbers
in the Cost column added up will always be 100%. The "Cost" column in the lower
pane shows the time spent while calling the function from the list. While adding
the numbers in this list up, you will most likely never reach 100% as the
selected function itself will also takes time to execute.</p>

<p>The "All Callers" and "All Calls" tabs show not only the direct calls from
<img class="l" src="/images/docs/kc-right-callers.png" align="left"/>
which the function was called respectively all directly made
function calls but also function calls made more levels up and down.
The upper pane in the screenshot on the left shows all functions calling the
current selected one, both directly and indirectly with other functions
inbetween them on the stack. The "Distance" column shows how many function
calls are between the listed and the current selected one (-1). If there are
different distances between two functions, it is shown as a range (for example
"5-24"). The number in parentheses is the median distance. The lower pane is
similar except that it shows information on functions called from the current
selected one, again either direct or indirect.</p>
